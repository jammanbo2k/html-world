
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>AIPI × ECI 벤치마크 — 글래스모피즘 (강화 스키마 인식)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Pretendard:wght@400;600;700&display=swap" rel="stylesheet">
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<style>
  :root{ --bg: linear-gradient(135deg,#0ea5e9 0%,#6366f1 45%,#8b5cf6 100%); --glass: rgba(255,255,255,0.16); --stroke: rgba(255,255,255,0.22); --text:#f8fafc; --muted:#e2e8f0; }
  *{ box-sizing:border-box; }
  body{ margin:0; padding:24px; font-family:'Pretendard',system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans KR',sans-serif; background:var(--bg); min-height:100vh; color:var(--text);}
  .grid{ display:grid; grid-template-columns:1.15fr 1fr; gap:16px;}
  .row{ display:flex; gap:12px; flex-wrap:wrap; align-items:center;}
  .glass{ background:var(--glass); border:1px solid var(--stroke); box-shadow:0 10px 30px rgba(0,0,0,.25); border-radius:18px; backdrop-filter:blur(18px) saturate(120%); -webkit-backdrop-filter:blur(18px) saturate(120%); padding:16px 18px;}
  h1{ font-size:22px; margin:0 0 10px; font-weight:700;} h2{ font-size:16px; margin:0 0 8px; font-weight:700;}
  .pill{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.22); font-size:12px;}
  label{ font-weight:600; font-size:13px; display:block; margin-bottom:6px;}
  select,input[type="file"],input[type="text"],button{ background:rgba(255,255,255,.14); border:1px solid rgba(255,255,255,.28); color:var(--text); border-radius:12px; padding:10px 12px; outline:none; font-size:13px;}
  select{ min-width:220px;} input[type="file"]{ padding:8px;} button{ cursor:pointer; font-weight:700;}
  button.primary{ background:linear-gradient(135deg,#14b8a6,#06b6d4); border:none;} button.ghost{ background:transparent; border:1px dashed rgba(255,255,255,.35); }
  .hint{ color:var(--muted); font-size:12px;}
  .kpi{ display:flex; gap:14px; flex-wrap:wrap;}
  .kpi .it{ flex:1 1 140px; min-width:140px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.22); border-radius:14px; padding:10px 12px;}
  .kpi .label{ font-size:12px; color:#e5e7eb;} .kpi .val{ font-size:18px; font-weight:700;}
  .panel{ height:560px; } #scatter,#residuals{ height:520px; }
  .stack{ display:flex; flex-direction:column; gap:16px;}
  .col{ display:flex; flex-direction:column; gap:12px;}
  .bad{ color:#fecaca;} table{ width:100%; border-collapse:collapse; font-size:12px;} th,td{ border-bottom:1px solid rgba(255,255,255,.18); padding:6px 4px;}
  .tag{ padding:4px 8px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.22); border-radius:999px; font-size:12px;}
  .divider{ height:1px; background:rgba(255,255,255,.2); margin:8px 0;}
  @media(max-width:1080px){ .grid{ grid-template-columns:1fr; } }
</style>
</head>
<body>
  <div class="glass" style="margin-bottom:14px;">
    <div class="row" style="justify-content:space-between;">
      <div>
        <h1>AIPI × ECI 벤치마크 — 글래스모피즘</h1>
        <div class="row">
          <span class="pill">스키마 자동 인식·복구(헤더 승격/BOM/대소문자/공백)</span>
          <span class="pill">ISO3 기반 지역·소득 자동 보강</span>
          <span class="pill">회귀·R²·잔차 Top 20</span>
        </div>
      </div>
      <div class="kpi">
        <div class="it"><div class="label">표본(유효 Join)</div><div class="val" id="kpiN">0</div></div>
        <div class="it"><div class="label">R² (OLS y~x)</div><div class="val" id="kpiR2">–</div></div>
        <div class="it"><div class="label">상관(피어슨 r)</div><div class="val" id="kpiR">–</div></div>
      </div>
    </div>
  </div>

  <div class="grid">
    <div class="stack">
      <div class="glass">
        <h2>1) 데이터 업로드</h2>
        <div class="row">
          <div class="col">
            <label>AIPI CSV</label>
            <input id="aipiFile" type="file" accept=".csv">
            <div class="hint">IMF <code>Country, iso3, type, AIPI</code> 또는 템플릿 <code>country, aipi, income_group, region[, oecd]</code></div>
          </div>
          <div class="col">
            <label>ECI CSV</label>
            <input id="eciFile" type="file" accept=".csv">
            <div class="hint">Growth Lab <code>country_iso3_code, eci_hs92|eci_sitc|eci_hs12</code> 또는 템플릿 <code>country, eci</code></div>
          </div>
          <div class="col">
            <label>(선택) ISO3→지역·소득 매핑 CSV</label>
            <input id="mapFile" type="file" accept=".csv">
            <div class="hint">컬럼: <code>iso3, income_group, region</code> (내장 매핑보다 우선)</div>
          </div>
        </div>
        <div class="divider"></div>
        <div class="row">
          <div class="col">
            <label>하이라이트 국가(쉼표 구분)</label>
            <input id="highlight" type="text" placeholder="예: Korea, Rep., Singapore, Rwanda">
          </div>
          <div class="col">
            <label>검색(부분 일치)</label>
            <input id="search" type="text" placeholder="국가명 검색">
          </div>
          <div class="col">
            <label>&nbsp;</label>
            <button id="btnUpdate" class="primary">차트 업데이트</button>
            <button id="btnDownload" class="ghost" disabled>병합 CSV 다운로드</button>
          </div>
        </div>
      </div>

      <div class="glass">
        <h2>2) 필터</h2>
        <div class="row">
          <div class="col">
            <label>지역(다중 선택)</label>
            <select id="region" multiple size="6"></select>
          </div>
          <div class="col">
            <label>소득그룹(다중 선택)</label>
            <select id="income" multiple size="6"></select>
          </div>
          <div class="col">
            <label>OECD만 보기</label>
            <select id="oecdOnly">
              <option value="any">모두</option>
              <option value="oecd">OECD만</option>
              <option value="non">OECD 제외</option>
            </select>
            <div class="hint">AIPI에 <code>oecd</code>가 없으면 내장 목록으로 판정</div>
          </div>
        </div>
      </div>

      <div class="glass panel">
        <h2>3) 산점도: AIPI (y) vs ECI (x)</h2>
        <div id="scatter"></div>
      </div>
    </div>

    <div class="stack">
      <div class="glass panel">
        <h2>4) 잔차 바차트: (실제 AIPI – 예측 AIPI)</h2>
        <div id="residuals"></div>
      </div>

      <div class="glass">
        <h2>5) 데이터 검증 로그</h2>
        <div id="log" class="hint">CSV 업로드 후 검사 결과가 표시됩니다.</div>
        <div class="divider"></div>
        <div id="invalid"></div>
      </div>

      <div class="glass">
        <h2>6) 국가 상세</h2>
        <div class="row">
          <div class="col" style="min-width:280px;">
            <label>국가 선택</label>
            <select id="countrySelect" size="8" style="min-width:280px;"></select>
          </div>
          <div class="col" style="flex:1;">
            <div class="kpi">
              <div class="it"><div class="label">AIPI</div><div class="val" id="dAipi">–</div></div>
              <div class="it"><div class="label">ECI</div><div class="val" id="dEci">–</div></div>
              <div class="it"><div class="label">예측 AIPI</div><div class="val" id="dPred">–</div></div>
              <div class="it"><div class="label">잔차</div><div class="val" id="dRes">–</div></div>
            </div>
            <div class="divider"></div>
            <div class="hint">*연도별 시계열이 포함되지 않아 미니 시계열은 제공하지 않습니다.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
let merged=[];

// --- helpers ---
function parseCSVFile(inputEl, cb){
  const f = inputEl.files[0];
  if (!f){ cb(null,null); return; }
  Papa.parse(f, { header:true, skipEmptyLines:true, complete: r => cb(r.data, r.meta.fields) });
}
function log(msg){ const el=document.getElementById('log'); el.innerHTML=(el.innerHTML? el.innerHTML+"<br>":"")+msg; }
function normalizeKey(s){ return (s||"").replace(/^\\ufeff/, "").trim().toLowerCase(); } // drop BOM, trim, lower
function normalizeVal(s){ return (s==null? "": String(s)).trim(); }
function normalizeName(s){ return (s||"").trim().toLowerCase(); }

// --- OECD & WB maps (same as before, abbreviated here) ---
const oecdISO = new Set(["AUS","AUT","BEL","CAN","CHL","COL","CRI","CZE","DNK","EST","FIN","FRA","DEU","GRC","HUN","ISL","IRL","ISR","ITA","JPN","KOR","LVA","LTU","LUX","MEX","NLD","NZL","NOR","POL","PRT","SVK","SVN","ESP","SWE","CHE","TUR","GBR","USA"]);
const wbMap = {"AUS":{"income_group":"High income","region":"East Asia & Pacific"},"AUT":{"income_group":"High income","region":"Europe & Central Asia"},"BEL":{"income_group":"High income","region":"Europe & Central Asia"},"CAN":{"income_group":"High income","region":"North America"},"CHL":{"income_group":"High income","region":"Latin America & Caribbean"},"COL":{"income_group":"Upper middle income","region":"Latin America & Caribbean"},"CRI":{"income_group":"Upper middle income","region":"Latin America & Caribbean"},"CZE":{"income_group":"High income","region":"Europe & Central Asia"},"DNK":{"income_group":"High income","region":"Europe & Central Asia"},"EST":{"income_group":"High income","region":"Europe & Central Asia"},"FIN":{"income_group":"High income","region":"Europe & Central Asia"},"FRA":{"income_group":"High income","region":"Europe & Central Asia"},"DEU":{"income_group":"High income","region":"Europe & Central Asia"},"GRC":{"income_group":"High income","region":"Europe & Central Asia"},"HUN":{"income_group":"High income","region":"Europe & Central Asia"},"ISL":{"income_group":"High income","region":"Europe & Central Asia"},"IRL":{"income_group":"High income","region":"Europe & Central Asia"},"ISR":{"income_group":"High income","region":"Middle East & North Africa"},"ITA":{"income_group":"High income","region":"Europe & Central Asia"},"JPN":{"income_group":"High income","region":"East Asia & Pacific"},"KOR":{"income_group":"High income","region":"East Asia & Pacific"},"LVA":{"income_group":"High income","region":"Europe & Central Asia"},"LTU":{"income_group":"High income","region":"Europe & Central Asia"},"LUX":{"income_group":"High income","region":"Europe & Central Asia"},"MEX":{"income_group":"Upper middle income","region":"Latin America & Caribbean"},"NLD":{"income_group":"High income","region":"Europe & Central Asia"},"NZL":{"income_group":"High income","region":"East Asia & Pacific"},"NOR":{"income_group":"High income","region":"Europe & Central Asia"},"POL":{"income_group":"High income","region":"Europe & Central Asia"},"PRT":{"income_group":"High income","region":"Europe & Central Asia"},"SVK":{"income_group":"High income","region":"Europe & Central Asia"},"SVN":{"income_group":"High income","region":"Europe & Central Asia"},"ESP":{"income_group":"High income","region":"Europe & Central Asia"},"SWE":{"income_group":"High income","region":"Europe & Central Asia"},"CHE":{"income_group":"High income","region":"Europe & Central Asia"},"TUR":{"income_group":"Upper middle income","region":"Europe & Central Asia"},"GBR":{"income_group":"High income","region":"Europe & Central Asia"},"USA":{"income_group":"High income","region":"North America"},"KAZ":{"income_group":"Upper middle income","region":"Europe & Central Asia"},"RWA":{"income_group":"Low income","region":"Sub-Saharan Africa"},"VNM":{"income_group":"Lower middle income","region":"East Asia & Pacific"},"SGP":{"income_group":"High income","region":"East Asia & Pacific"},"HKG":{"income_group":"High income","region":"East Asia & Pacific"}};

// --- robust header promotion ---
function maybePromoteHeader(rows, fields){
  if (!rows || !rows.length) return {rows, fields};
  const lower = fields.map(normalizeKey);
  const unnamedLike = lower.filter(f => f.startsWith("unnamed")).length >= Math.floor(fields.length * 0.6); // 60%+ unnamed
  const firstRowVals = Object.values(rows[0]).map(v => normalizeVal(v));
  const headerTokens = new Set(firstRowVals.map(v => normalizeKey(v)));
  const needsPromote = unnamedLike || (headerTokens.has("country") && headerTokens.has("aipi")) || (headerTokens.has("country") && headerTokens.has("iso3") && headerTokens.has("aipi"));
  if (!needsPromote) return {rows, fields};
  const newFields = firstRowVals;
  const newRows = rows.slice(1).map(r => {
    const o={};
    for (let i=0;i<fields.length;i++){
      o[newFields[i]] = r[fields[i]];
    }
    return o;
  });
  return {rows:newRows, fields:newFields};
}

function hasKeys(fields, keys){
  const set = new Set(fields.map(normalizeKey));
  return keys.every(k => set.has(normalizeKey(k)));
}

// --- adapters ---
function adaptAIPI(rows, fields){
  // normalize field names (trim/BOM/lower)
  const fLower = fields.map(normalizeKey);

  // Case A: template schema (country,aipi,...), case-insensitive
  const templateOK = hasKeys(fields, ["country","aipi"]);
  // Case B: IMF schema (Country, iso3, type, AIPI), case-insensitive
  const imfOK = hasKeys(fields, ["country","aipi"]) && (hasKeys(fields, ["iso3"]) || hasKeys(fields, ["type"]) );

  let bad=[], out=[];
  if (templateOK || imfOK){
    // Build a name->index map
    const idx = {}; fields.forEach((f,i)=> idx[normalizeKey(f)] = i);
    const pick = (obj, name) => obj[fields[idx[normalizeKey(name)]]] ?? obj[name];

    for (const r of rows){
      const c = normalizeVal(pick(r,"country"));
      const iso3 = normalizeVal(pick(r,"iso3"));
      const t = normalizeVal(pick(r,"type"));
      const a = parseFloat(pick(r,"aipi"));
      if (!c){ bad.push({where:"AIPI", country:c, reason:"country 빈값"}); continue; }
      if (!(a===0 || Number.isFinite(a))){ bad.push({where:"AIPI", country:c, reason:"AIPI NaN"}); continue; }
      const income = normalizeVal(pick(r,"income_group"));
      const region = normalizeVal(pick(r,"region"));
      const oecd = String(pick(r,"oecd")).toLowerCase()==="true" ? true : null;
      out.push({ country:c, iso3:iso3, aipi:a, income:income, region:region, type:t, oecd:oecd });
    }
    return {rows: out, bad};
  }
  throw new Error("지원하지 않는 AIPI 스키마입니다. (country,aipi,...) 또는 (Country,AIPI,...) 형식을 사용하세요.");
}

function adaptECI(rows, fields){
  const tplOK = hasKeys(fields, ["country","eci"]);
  const atlasOK = hasKeys(fields, ["country_iso3_code"]) && (hasKeys(fields, ["eci_hs92"]) || hasKeys(fields, ["eci_sitc"]) || hasKeys(fields, ["eci_hs12"]));
  let bad=[], out=[];
  if (tplOK){
    const idx = {}; fields.forEach((f,i)=> idx[normalizeKey(f)] = i);
    const pick = (obj, name) => obj[fields[idx[normalizeKey(name)]]] ?? obj[name];
    for (const r of rows){
      const c = normalizeVal(pick(r,"country"));
      const e = parseFloat(pick(r,"eci"));
      if (!c){ bad.push({where:"ECI", country:c, reason:"country 빈값"}); continue; }
      if (!(e===0 || Number.isFinite(e))){ bad.push({where:"ECI", country:c, reason:"eci NaN"}); continue; }
      out.push({ country:c, iso3:"", eci:e });
    }
    return {rows: out, bad};
  }
  if (atlasOK){
    const idx = {}; fields.forEach((f,i)=> idx[normalizeKey(f)] = i);
    const pick = (obj, name) => obj[fields[idx[normalizeKey(name)]]] ?? obj[name];
    for (const r of rows){
      const code = normalizeVal(pick(r,"country_iso3_code")).toUpperCase();
      let e = null;
      const h92 = pick(r,"eci_hs92"), sitc = pick(r,"eci_sitc"), h12 = pick(r,"eci_hs12");
      if (h92!==undefined) e = parseFloat(h92);
      if (!Number.isFinite(e) && sitc!==undefined) e = parseFloat(sitc);
      if (!Number.isFinite(e) && h12!==undefined) e = parseFloat(h12);
      if (!code){ bad.push({where:"ECI", country:code, reason:"iso3 빈값"}); continue; }
      if (!(e===0 || Number.isFinite(e))){ bad.push({where:"ECI", country:code, reason:"ECI NaN"}); continue; }
      out.push({ country:"", iso3:code, eci:e });
    }
    return {rows: out, bad};
  }
  throw new Error("지원하지 않는 ECI 스키마입니다. (country,eci) 또는 (country_iso3_code, eci_*) 형식을 사용하세요.");
}

// optional map
function adaptMap(rows, fields){
  if (!hasKeys(fields, ["iso3","income_group","region"])) throw new Error("매핑 CSV 스키마는 iso3,income_group,region 이어야 합니다.");
  const out={};
  for (const r of rows){
    const iso3 = normalizeVal(r[fields.findIndex(f=>normalizeKey(f)==="iso3")]!==undefined ? r[fields.findIndex(f=>normalizeKey(f)==="iso3")] : r["iso3"]).toUpperCase();
    if (!iso3) continue;
    const inc = normalizeVal(r[fields.findIndex(f=>normalizeKey(f)==="income_group")]!==undefined ? r[fields.findIndex(f=>normalizeKey(f)==="income_group")] : r["income_group"]);
    const reg = normalizeVal(r[fields.findIndex(f=>normalizeKey(f)==="region")]!==undefined ? r[fields.findIndex(f=>normalizeKey(f)==="region")] : r["region"]);
    out[iso3] = {income_group:inc, region:reg};
  }
  return out;
}

function joinAndAugment(aipi, eci, mapDict){
  const eByName = new Map(eci.filter(r=>r.country).map(r=>[normalizeName(r.country), r]));
  const eByIso3 = new Map(eci.filter(r=>r.iso3).map(r=>[normalizeName(r.iso3), r]));
  const out=[];
  for (const a of aipi){
    let e = null;
    if (a.iso3) e = eByIso3.get(normalizeName(a.iso3));
    if (!e) e = eByName.get(normalizeName(a.country));
    if (!e) continue;

    const iso = (a.iso3||"").toUpperCase();
    const oecd = (a.oecd!==null && a.oecd!==undefined) ? !!a.oecd : (iso ? oecdISO.has(iso) : false);

    let income = (a.income||"");
    let region = (a.region||"");
    const built = iso && (wbMap[iso] || null);
    const userM = (mapDict && iso && mapDict[iso]) ? mapDict[iso] : null;

    if ((!income || income==="AE" || income==="EMDE")){
      if (userM && userM.income_group) income = userM.income_group;
      else if (built && built.income_group) income = built.income_group;
    }
    if (!region){
      if (userM && userM.region) region = userM.region;
      else if (built && built.region) region = built.region;
    }

    out.push({ country:a.country, aipi:a.aipi, eci:e.eci, income:income, region:region, oecd:oecd });
  }
  return out;
}

// UI handlers
function fillInvalidTable(badA, badE){
  let html = "";
  function tbl(title, arr){
    if (!arr || !arr.length) return `<div class="tag">${title}: 문제 없음</div>`;
    const rows = arr.map(r=>`<tr><td>${r.where}</td><td>${r.country||''}</td><td class="bad">${r.reason}</td></tr>`).join("");
    return `<h3 style="font-size:13px;">${title}</h3><table><thead><tr><th>소스</th><th>키</th><th>사유</th></tr></thead><tbody>${rows}</tbody></table>`;
  }
  html += tbl("AIPI 유효성", badA); html += "<div style='height:8px;'></div>"; html += tbl("ECI 유효성", badE);
  document.getElementById('invalid').innerHTML = html;
}
function populateFilters(data){
  const regSel=document.getElementById('region'), incSel=document.getElementById('income'), cSel=document.getElementById('countrySelect');
  const regions=Array.from(new Set(data.map(d=>d.region).filter(Boolean))).sort();
  const incomes=Array.from(new Set(data.map(d=>d.income).filter(Boolean))).sort();
  regSel.innerHTML=""; incSel.innerHTML=""; cSel.innerHTML="";
  for (const r of regions){ const o=document.createElement('option'); o.value=r; o.textContent=r; regSel.appendChild(o); }
  for (const i of incomes){ const o=document.createElement('option'); o.value=i; o.textContent=i; incSel.appendChild(o); }
  data.map(d=>d.country).sort().forEach(c=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; cSel.appendChild(o); });
}
function getMulti(sel){ return Array.from(sel.selectedOptions).map(o=>o.value); }
function applyFilters(data){
  const regs=getMulti(document.getElementById('region')), incs=getMulti(document.getElementById('income'));
  const mode=document.getElementById('oecdOnly').value, q=(document.getElementById('search').value||"").trim().toLowerCase();
  return data.filter(d=>{
    if (regs.length && !regs.includes(d.region||"")) return false;
    if (incs.length && !incs.includes(d.income||"")) return false;
    if (mode==="oecd" && !d.oecd) return false;
    if (mode==="non" && d.oecd) return false;
    if (q && !d.country.toLowerCase().includes(q)) return false;
    return true;
  });
}
function pearson(x,y){
  const n=x.length; if (n===0) return null;
  const mx=x.reduce((a,b)=>a+b,0)/n, my=y.reduce((a,b)=>a+b,0)/n;
  let num=0, dx=0, dy=0; for(let i=0;i<n;i++){ const vx=x[i]-mx, vy=y[i]-my; num+=vx*vy; dx+=vx*vx; dy+=vy*vy; }
  const den=Math.sqrt(dx*dy); return den===0?0:num/den;
}
function linreg(x,y){
  const n=x.length; if (n<2) return null;
  const sx=x.reduce((a,b)=>a+b,0), sy=y.reduce((a,b)=>a+b,0);
  const sxx=x.reduce((a,b)=>a+b*b,0), sxy=x.reduce((a,b,i)=>a+b*y[i],0);
  const denom=n*sxx - sx*sx; if (denom===0) return null;
  const slope=(n*sxy - sx*sy)/denom, intercept=(sy - slope*sx)/n;
  const yhat=x.map(xi=>slope*xi+intercept);
  const ssres=y.reduce((a,yi,i)=>a+(yi-yhat[i])**2,0);
  const ymean=sy/n, sstot=y.reduce((a,yi)=>a+(yi-ymean)**2,0);
  return {slope, intercept, r2:(sstot===0?0:1-ssres/sstot)};
}
function renderScatter(data, lr, highlights){
  const base={ x:data.map(d=>d.eci), y:data.map(d=>d.aipi), text:data.map(d=>`${d.country}<br>ECI: ${d.eci}<br>AIPI: ${d.aipi}`), mode:'markers', type:'scatter', hoverinfo:'text', marker:{size:9, opacity:.9} };
  const hi = data.filter(d=>highlights.has(d.country.toLowerCase()));
  const traces=[base];
  if (hi.length){ traces.push({ x:hi.map(d=>d.eci), y:hi.map(d=>d.aipi), text:hi.map(d=>d.country), mode:'markers+text', textposition:'top center', marker:{size:12, line:{width:2, color:'#fff'}} }); }
  if (lr && data.length>=2){
    const xs=data.map(d=>d.eci), minX=Math.min(...xs), maxX=Math.max(...xs);
    const rx=[minX,maxX], ry=rx.map(v=>lr.slope*v+lr.intercept);
    traces.push({ x:rx, y:ry, mode:'lines', line:{dash:'dot'}, name:'회귀선' });
  }
  Plotly.newPlot('scatter', traces, { paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
    xaxis:{ title:'ECI', gridcolor:'rgba(255,255,255,.15)' }, yaxis:{ title:'AIPI', gridcolor:'rgba(255,255,255,.15)' }, margin:{t:20,r:10,b:50,l:50} }, {responsive:true});
}
function renderResiduals(data, lr, topN=20){
  if (!lr){ Plotly.purge('residuals'); return; }
  const arr=data.map(d=>{ const p=lr.slope*d.eci+lr.intercept; return {country:d.country, res:d.aipi-p}; })
               .sort((a,b)=>Math.abs(b.res)-Math.abs(a.res)).slice(0,topN);
  Plotly.newPlot('residuals', [{x:arr.map(d=>d.country), y:arr.map(d=>d.res), type:'bar'}],
    { paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)',
      yaxis:{ title:'잔차 (AIPI - 예측)', gridcolor:'rgba(255,255,255,.15)' }, margin:{t:10,r:10,b:120,l:50} }, {responsive:true});
}
function toCSV(rows){
  if (!rows || !rows.length) return "";
  const cols=Object.keys(rows[0]); const head=cols.join(",");
  const body=rows.map(r=>cols.map(c=> (r[c]!==undefined && r[c]!==null) ? String(r[c]).replace(/,/g,";") : "" ).join(",")).join("\\n");
  return head+"\\n"+body;
}
function enableDownload(data){
  const csv=toCSV(data); const blob=new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url=URL.createObjectURL(blob); const btn=document.getElementById('btnDownload');
  btn.disabled = !data.length; btn.onclick = ()=>{ const a=document.createElement('a'); a.href=url; a.download='merged_aipi_eci_augmented.csv'; a.click(); };
}
function populateFilters(data){
  const regSel=document.getElementById('region'), incSel=document.getElementById('income'), cSel=document.getElementById('countrySelect');
  const regions=Array.from(new Set(data.map(d=>d.region).filter(Boolean))).sort();
  const incomes=Array.from(new Set(data.map(d=>d.income).filter(Boolean))).sort();
  regSel.innerHTML=""; incSel.innerHTML=""; cSel.innerHTML="";
  for (const r of regions){ const o=document.createElement('option'); o.value=r; o.textContent=r; regSel.appendChild(o); }
  for (const i of incomes){ const o=document.createElement('option'); o.value=i; o.textContent=i; incSel.appendChild(o); }
  data.map(d=>d.country).sort().forEach(c=>{ const o=document.createElement('option'); o.value=c; o.textContent=c; cSel.appendChild(o); });
}

// main flow
function getMulti(sel){ return Array.from(sel.selectedOptions).map(o=>o.value); }
function applyFilters(data){
  const regs=getMulti(document.getElementById('region')), incs=getMulti(document.getElementById('income'));
  const mode=document.getElementById('oecdOnly').value, q=(document.getElementById('search').value||"").trim().toLowerCase();
  return data.filter(d=>{
    if (regs.length && !regs.includes(d.region||"")) return false;
    if (incs.length && !incs.includes(d.income||"")) return false;
    if (mode==="oecd" && !d.oecd) return false;
    if (mode==="non" && d.oecd) return false;
    if (q && !d.country.toLowerCase().includes(q)) return false;
    return true;
  });
}
function updateDetail(data, lr){
  const sel=document.getElementById('countrySelect'); const opt=sel.value;
  const r=data.find(d=>d.country===opt);
  const pred = (lr && r) ? (lr.slope*r.eci + lr.intercept) : NaN;
  document.getElementById('dAipi').textContent = r? r.aipi : '–';
  document.getElementById('dEci').textContent = r? r.eci : '–';
  document.getElementById('dPred').textContent = (r && Number.isFinite(pred)) ? pred.toFixed(3) : '–';
  document.getElementById('dRes').textContent = (r && Number.isFinite(pred)) ? (r.aipi - pred).toFixed(3) : '–';
}
function updateAll(){
  const data = applyFilters(merged);
  const xs=data.map(d=>d.eci), ys=data.map(d=>d.aipi);
  let r=null, lr=null;
  if (xs.length>=2){
    const n=xs.length, mx=xs.reduce((a,b)=>a+b,0)/n, my=ys.reduce((a,b)=>a+b,0)/n;
    let num=0, dx=0, dy=0; for(let i=0;i<n;i++){ const vx=xs[i]-mx, vy=ys[i]-my; num+=vx*vy; dx+=vx*vx; dy+=vy*vy; }
    r = (Math.sqrt(dx*dy)===0)? 0 : num/Math.sqrt(dx*dy);
    const sx=xs.reduce((a,b)=>a+b,0), sy=ys.reduce((a,b)=>a+b,0);
    const sxx=xs.reduce((a,b)=>a+b*b,0), sxy=xs.reduce((a,b,i)=>a+b*ys[i],0);
    const denom=n*sxx - sx*sx; if (denom!==0){
      const slope=(n*sxy - sx*sy)/denom, intercept=(sy - slope*sx)/n;
      const yhat=xs.map(x=>slope*x+intercept);
      const ssres=ys.reduce((a,yi,i)=>a+(yi-yhat[i])**2,0), ymean=sy/n, sstot=ys.reduce((a,yi)=>a+(yi-ymean)**2,0);
      lr = {slope, intercept, r2:(sstot===0?0:1-ssres/sstot)};
    }
  }
  document.getElementById('kpiN').textContent = data.length;
  document.getElementById('kpiR').textContent = (r!==null? r.toFixed(2) : "–");
  document.getElementById('kpiR2').textContent = (lr? lr.r2.toFixed(2) : "–");

  const highlights = new Set((document.getElementById('highlight').value||"").split(",").map(s=>s.trim().toLowerCase()).filter(Boolean));
  renderScatter(data, lr, highlights);
  renderResiduals(data, lr, 20);
  updateDetail(data, lr);
  enableDownload(data);
}

document.getElementById('btnUpdate').addEventListener('click', ()=>{
  const aEl=document.getElementById('aipiFile');
  const eEl=document.getElementById('eciFile');
  const mEl=document.getElementById('mapFile');
  if (!aEl.files[0] || !eEl.files[0]){ log("AIPI와 ECI CSV를 모두 업로드하세요."); return; }
  document.getElementById('log').innerHTML = "";

  // AIPI parse + robust header promotion
  parseCSVFile(aEl, (rowsA, fieldsA)=>{
    try{
      const promoted = maybePromoteHeader(rowsA, fieldsA);
      const A = adaptAIPI(promoted.rows, promoted.fields);
      log(`AIPI 로드 완료: ${A.rows.length}행 (문제: ${A.bad.length})`);

      // ECI parse
      parseCSVFile(eEl, (rowsE, fieldsE)=>{
        try{
          const E = adaptECI(rowsE, fieldsE);
          log(`ECI 로드 완료: ${E.rows.length}행 (문제: ${E.bad.length})`);

          const finish = (mapDict)=>{
            merged = joinAndAugment(A.rows, E.rows, mapDict);
            log(`유효 Join: ${merged.length}행 (자동 보강 반영)`);
            fillInvalidTable(A.bad, E.bad);
            populateFilters(merged);
            updateAll();
          };

          // Optional mapping
          if (mEl.files[0]){
            parseCSVFile(mEl, (rowsM, fieldsM)=>{
              try{ const mapDict = adaptMap(rowsM, fieldsM); log(`보강 매핑 로드 완료: ${Object.keys(mapDict).length}개 ISO3`); finish(mapDict); }
              catch(err){ log(`<span class='bad'>매핑 CSV 오류: ${err.message}</span>`); finish(null); }
            });
          } else {
            finish(null);
          }

        }catch(err){ log(`<span class='bad'>ECI 오류: ${err.message}</span>`); }
      });
    }catch(err){ log(`<span class='bad'>AIPI 오류: ${err.message}</span>`); }
  });
});
document.getElementById('region').addEventListener('change', updateAll);
document.getElementById('income').addEventListener('change', updateAll);
document.getElementById('oecdOnly').addEventListener('change', updateAll);
document.getElementById('search').addEventListener('input', updateAll);
document.getElementById('highlight').addEventListener('change', updateAll);
document.getElementById('countrySelect').addEventListener('change', ()=>{
  const data=applyFilters(merged);
  const xs=data.map(d=>d.eci), ys=data.map(d=>d.aipi);
  let lr=null; if (xs.length>=2){
    const n=xs.length, sx=xs.reduce((a,b)=>a+b,0), sy=ys.reduce((a,b)=>a+b,0);
    const sxx=xs.reduce((a,b)=>a+b*b,0), sxy=xs.reduce((a,b,i)=>a+b*ys[i],0); const denom=n*sxx - sx*sx;
    if (denom!==0){ const slope=(n*sxy - sx*sy)/denom, intercept=(sy - slope*sx)/n; lr={slope, intercept, r2:0}; }
  }
  updateDetail(data, lr);
});
</script>
</body>
</html>
